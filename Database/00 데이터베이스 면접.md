## 데이터베이스 면접 질문 연습

### 데이터베이스를 사용하는 이유
* 데이터베이스를 사용하면 SW 개발에 필수적인 데이터를 효율적으로 저장, 관리, 검색 조작 할 수 있습니다.  
* 또한, 데이터베이스는 데이터의 독립성, 무결성, 보안성, 일관성과 같은 특징을 보장할 수 있습니다.

### 데이터베이스의 특징
#### 데이터의 독립성
* 데이터베이스와 응용프로그램간의 독립성
* 물리적 독립성 : 데이터베이스 사이즈를 늘리거나 성능 향상을 위해 데이터 파일을 늘리거나 새롭게 추가하더라도 관련된 응용 프로그램을 수정할 필요가 없음
* 논리적 독립성 : 데이터베이스는 논리적인 구조로 다양한 응용 프로그램의 논리적 요구를 만족
#### 데이터의 무결성
* 데이터의 유효성을 검증하고 오류를 방지
* 여러 경로를 통해 잘못된 데이터가 발생하는 경우의 수를 방지하는 기능
* 데이터의 유효성 검사를 통해 데이터의 무결성을 구현
#### 데이터의 보안성
* 암호화, 권한 관리, 접근 제어를 통해 데이터 보호
* 인가된 사용자들만 데이터베이스나 데이터베이스 내의 자원에 접근할 수 있도록 계정 관리 또는 접근 권한을 설정함으로써 모든 데이터에 보안을 구현
#### 데이터의 일관성
* 여러 사용자가 동시에 데이터를 사용하더라도, 데이터베이스에서는 트랜잭션과 잠금을 통해 데이터 일관성을 보장
* 연관된 정보를 논리적인 구조로 관리함으로써 어떤 하나의 데이터만 변경했을 경우 발생할 수 있는 데이터의 불일치성을 배제 
* 작업 중 일부 데이터만 변경되어 나머지 데이터와 일치하지 않는 경우의 수를 배제
#### 데이터 중복 최소화
* 데이터베이스는 데이터를 통합해서 관리함으로써 파일 시스템의 단점 중 하나인 자료의 중복과 데이터의 중복성 문제를 해결

### 데이터베이스의 성능을 높이는 방법
#### 인덱스 최적화
* 적절한 인덱스를 생성하고 관리하여 데이터 검색 속도를 향상시킬 수 있습니다.
* 예를 들어, 우리의 특정 테이블에서 자주 사용되는 검색 쿼리가 있다면 해당 열에 인덱스를 생성하여 검색 속도를 높일 수 있습니다.

#### 쿼리 최적화
* 쿼리 실행 계획을 최적화하여 쿼리 실행시간을 단축시켜 데이터베이스의 성능을 향상시킬 수 있습니다. 
* 예를 들어, 비효율적인 조인이나 서브쿼리를 개선하거나, 쿼리에 사용되는 함수를 최소화함으로써 쿼리의 실행 속도를 개선할 수 있습니다.

### 하드웨어 및 저장소의 최적화
* 고성능의 서버 하드웨어를 사용하거나, SSD와 같은 고속 저장장치를 사용하여 데이터베이스의 성능을 향상시킬 수 있습니다.

### 정규화 반정규화
* 반정규화를 통해 중복 데이터를 일부 허용하며 검색 속도를 개선할 수 있습니다.

### 인덱스란 무엇인가?
* 인덱스는 데이터베이스에서 원하는 검색 속도를 향상시키기 위해 사용하는 장치(자료구조) 입니다.
* 특정한 컬럼에 대해 정렬된 데이터로, 검색 및 조회 작업을 빠르게 할 수 있도록 합니다.
* 하지만 인덱스를 사용하면 데이터 삽입, 삭제, 수정과 같은 작업에 대해서 추가적인 비용(overhead)이 들기 때문에 적절하게 설계하여 사용해야 합니다.
* 보통 b+tree 자료구조를 활용하여 인덱스 생성합니다.

### 인덱스에 사용하는 자료구조
* b+tree는 b-tree의 변형으로 내부 노드에는 키 값만 저장하고, 리프 노드에는 키 값와 데이를 저장 합니다.
* 대용량의 데이터를 관리하는 것에 효과적입니다.

### Primary Index vs Secondary Index
* Primary Index는 PK를 기반으로 레코드를 정렬하고 저장하여 빠른 주 키 검색을 가능하게 하며, 
* Secondary Index는 PK 이외의 컬럼을 기반으로 데이터를 검색하고 정렬하는 데 사용됩니다

### Composite Index
* Composite Index는 두 개 이상의 컬럼을 기반으로 생성되는 인덱스입니다. 
* 하나의 인덱스가 여러 컬럼의 조합으로 구성됩니다. 
* 이를 통해 여러 컬럼에 대한 복합 검색을 효율적으로 수행할 수 있습니다.

### Index의 성능과 고려해야할 사항
* 인덱스를 생성하면 데이터베이스에 삽입, 수정, 삭제 작업이 발생할 때 추가적인 Overhead가 발생할 수 있습니다. 
* 이로 인해 데이터베이스의 성능이 저하될 수 있으므로 인덱스를 적절히 관리해야 합니다.
* 또한 너무 많은 인덱스를 생성하거나 자주 업데이트되는 열에 대해 인덱스를 생성하면 성능을 저하시킬 수 있습니다.

### 정규화란?
* 관계형 데이터베이스에서 중복을 최소화하고 데이터의 일관성을 유지하기기 위해 데이터를 구조화하는 작업
* 정규화는 테이블을 여러 개의 릴레이션으로 분해하고, 각 정규화 규칙에 맞게 관계를 설정하고 중복을 제거
* 데이터의 일관성과 무결성을 유지하며 효율성을 향상시킬 수 있음

### 각 정규화 설명
#### 제1정규화
* 테이블의 각 열이 원자적인 값을 갖도록 구성
* 각 열은 더 이상 분해할 수 없는 하나의 값만을 가짐

#### 제2정규화
* 제1정규형에서 부분 함수 종속성을 제거한 상태
* **부분 함수 종속성**
  * **기본키가 아니라 다른 열(복합키의 일부분)에 부분족으로 종속되어 있는 경우**
* 부분 함수 종속성이 있는 열들을 별도의 테이블로 분해하여,
* 각각의 테이블이 기본키에 종속되는 완전 함수 종속성을 가지도록 함

#### 제3정규화
* 제2정규형에서 이행적 함수 종속을 제거한 상태
* **이행적 함수 종속**
  * **A -> B 이고 B -> C 여서 A -> C 가 성립**하여 A가 C에 종속되는 경우
* 기본키가 아닌 일반 칼럼에 의존하는 칼럼(이행적 함수 종속성이 있는 열)을 별도의 테이블로 분해하여,
* 기본키에 직접적으로 종속되도록 함

#### BCNF 정규화
* 제3정규형에서 모든 결정자가 후보키인 상태
* 결정자
  * A -> B 일 때, A는 결정자, B는 종속자

### 정규화의 장점과 단점?
#### 장점
* 데이터 일관성 보장하여 신뢰성 향상
* 데이터 중복 최소화하여 용량 절약
* 유지보수에 용이
* 삽입, 삭제, 수정 이상 등 이상현상 문제 해결
* 검색 및 조인 작업이 빨라질 수 있음

#### 단점
* 데이터베이스의 구조가 복잡해져서 
* 조인 비용이 증가
* 쓰기 비용 증가

### 결론
* 적절한 정규화는 일관성 보장과 중복을 최소화하여 효율이 증가하지만,
* 과도한 정규화는 복잡성을 증가시켜 비용 증가 및 효율이 떨어짐
* 따라서 상황과 시스템에 맞게 적절한 정규화가 필요하고, 필요시 반정규화 적용

### 반정규화 비정규화 란?
* 정규화된 모델을 중복, 통합, 분리 등을 하여 시스템의 성능 및 유지보수성 향상

### 어떤 경우에 반정규화?
* 읽기 속도 향상이 필요할 때
  * 조회 시 지나치게 많은 조인 연산으로 조회 성능 저하가 있을 때
* 복잡한 쿼리를 간소화 할 때
  * 복잡한 조인 연산이나 서브쿼리를 간소화 할 때
* 캐시 데이터 관리할때
  * 캐시 데이터의 읽기 성능 최적화
* 자주 사용하는 테이블이 반정규화된 상태가 최적일 때

### 트랜잭션이란?
* 데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위
* 여러 개의 쿼리들을 하나로 묶는 단위
* 원자성, 일관성, 고립성, 지속성 특성을 지님

### 원자성
* 트랜잭션과 관련된 모든 일이 수행되거나 모두 수행되지 않거나를 보장
* 트랜잭션 중간에 문제가 발생하면 롤백(rollback)하여 이전 상태로 되돌림

### 일관성
* 트랜잭션이 실행되기 전과 후에 데이터베이스는 항상 일관된 상태를 유지

### 고립성
* 각각의 트랜잭션은 서로의 작업에 간섭없이 독립적으로 수행

### 지속성
* 성공적으로 수행된 트랜잭션의 결과는 데이터베이스에 영구적으로 반영되어야 함